---
layout: post
title: 
subtitle: Classroom 테이블에서 Select Query 병목 문제를 해결하기 위한 최적화 전략 탐구 (라이브 강의 여부(is_live) 판단 쿼리의 성능 개선 방안)
categories: 
    - OceanAcademy
tags: [spring, mysql]
---

## 요약



## 개요

### 문제 상황

관계형 데이터 베이스로 구현한 데이터베이스 중 Classroom 테이블에 Select query의 병목이 예상된다.
Classroom 테이블은 페이지에서 가장 많은 api요청을 감당한다. 특히 is_live라는 라이브 강의 진행중인지 여부를 판단하는 칼럼이 있는데, 메인 페이지에 라이브 중인 강의를 표기하며, 라이브 강의 여부를 판단하는 쿼리가 다수 예상된다.

### 활동 내용

정량적인 성능 측정 방법과 병목을 해결할수있는 기술적 해결 방안을 찾고,
이를 실제로 적용해보며 개선된 성능을 수치화 해본다.

## 해결 방안 탐구

### 분석 방법 후보
 
1. 쿼리 로깅 및 분석(Query Logging & Analysis)  
설명: 현재 쿼리의 성능을 분석하여 병목 지점을 파악하는 것이 필요하다. 이 과정에서 쿼리 실행 시간을 모니터링하고, 성능 병목이 발생하는 원인을 찾아야 한다.  
장점: 실시간으로 쿼리 성능을 모니터링하여 특정 쿼리가 병목이 되는 시점을 정확히 파악할 수 있다.  
구현 방안:  
- Slow query 로그를 설정하여 오래 걸리는 쿼리를 분석한다.  
- 쿼리 실행 계획을 확인해 쿼리 최적화 지점을 파악한다(EXPLAIN, DESCRIBE 명령어).

2. 로드테스트 load test

### 해결 방안 후보

하나의 테이블에 Select Query가 병목되어 성능에 이슈가 예상되는 현 상황에서 해결방안을 탐구해 보았다.

1. 캐싱(Caching)  
설명: 빈번하게 조회되는 데이터는 캐싱을 통해 데이터베이스 쿼리를 줄일 수 있다. 캐시를 이용하면 자주 사용되는 데이터를 메모리에 저장하고, 데이터베이스로의 접근을 최소화할 수 있다.  
장점: 쿼리 횟수를 크게 줄여 병목을 완화하고, 응답 시간을 단축할 수 있다.  
구현 방안:  
- Redis, Memcached와 같은 인메모리 캐시를 활용해 자주 조회되는 데이터를 캐시한다.  
- Spring Cache Abstraction을 사용해 간편하게 캐싱 로직을 추가한다.  
- 캐시 만료 정책(예: TTL, ETag, Last-Modified)을 적절히 설정해 최신 데이터를 유지한다.

2. SQL 최적화 (JPQL/SQL 직접 사용)  
설명: Spring JPA의 쿼리 생성은 편리하지만, 복잡한 쿼리나 성능이 중요한 쿼리에서는 비효율적일 수 있다. 직접 SQL을 작성해 효율적인 쿼리를 구현하는 것이 도움이 될 수 있다.  
장점: 더 세밀하게 쿼리를 최적화할 수 있으며, 복잡한 비즈니스 로직에 맞는 맞춤형 쿼리를 작성할 수 있다.
구현 방안:  
- JPA의 `@Query`를 통해 네이티브 SQL을 작성하여 특정 상황에 맞는 최적화된 쿼리를 작성한다.  
- 복잡한 조인(join), 서브쿼리(subquery) 등을 최적화하여 쿼리의 성능을 개선한다.

3. 셀렉트 쿼리 최적화  
설명: SELECT 쿼리의 범위와 데이터양을 최소화하고, 불필요한 데이터를 요청하지 않도록 쿼리를 최적화하는 것이 중요하다.  
장점: 데이터 양을 줄여 네트워크 트래픽을 감소시키고, 응답 속도를 향상시킨다.  
구현 방안:  
- 필요한 컬럼만 SELECT하도록 쿼리를 작성한다 (`SELECT *` 지양).  
- 페이징(Pagination)을 활용해 대량 데이터를 한 번에 로딩하지 않도록 처리한다.  
- N+1 문제를 해결하고, Eager loading을 지양하며, Lazy loading으로 필요한 데이터만 로드한다.

4. 인덱싱(Indexing)  
설명: 데이터베이스에서 쿼리 성능을 높이기 위해 적절한 인덱스를 설정하는 것은 매우 중요한 최적화 방법이다.  
장점: 특정 컬럼에 인덱스를 추가하면 조회 성능이 대폭 개선된다.  
구현 방안:  
- 자주 조회되는 컬럼 또는 WHERE 절에 자주 사용되는 컬럼에 인덱스를 추가한다.  
- 복합 인덱스(composite index)나 유니크 인덱스(unique index)를 적절히 활용한다.  
- 인덱스가 지나치게 많으면 오히려 쓰기 성능에 영향을 미칠 수 있으므로, 필요한 인덱스만 설정한다.

5. 데이터베이스 샤딩(Database Sharding)  
설명: 데이터베이스를 수평적으로 분할하여 테이블의 데이터를 여러 서버에 나누어 저장하는 방법이다. 테이블 단위로 부하를 분산시킬 수 있다.  
장점: 데이터가 분산되어 더 많은 요청을 효율적으로 처리할 수 있으며, 스케일링이 용이하다.  
구현 방안:  
- Sharding key를 기준으로 데이터를 분산 저장한다.  
- 각 샤드에 별도의 연결을 사용해 성능을 개선한다.

6. 데이터베이스 리플리케이션(Replication)  
설명: 읽기 성능을 개선하기 위해 Master-Slave 구조로 리플리케이션을 설정할 수 있다. Master에서는 쓰기 작업을 처리하고, Slave에서는 읽기 작업을 처리하도록 분산시킬 수 있다.  
장점: 읽기 작업의 부하를 Slave 서버에 분산시켜 성능을 개선할 수 있다.  
구현 방안:  
- Master-Slave 구조로 읽기 전용 쿼리를 Slave 서버로 라우팅한다.  
- Spring에서 `@Primary`와 `@Qualifier`를 이용해 읽기/쓰기 구분을 한다.

7. 비동기 처리 또는 큐 활용(Asynchronous Processing or Queues)  
설명: 트랜잭션이 아닌 비동기 작업으로 쿼리할 수 있는 부분은 비동기적으로 처리하거나, 메시지 큐를 사용해 데이터 처리 작업을 분산시킬 수 있다.  
장점: 웹 서비스의 응답 시간을 단축하고, 쿼리 부하를 줄일 수 있다.  
구현 방안:  
- 비동기 처리로 병목 구간을 백그라운드로 넘겨 웹 서비스의 처리 속도를 향상시킨다.  
- RabbitMQ, Kafka 등의 큐를 사용해 데이터 처리를 분산시킨다.

8. 배치 처리(Batch Processing)  
설명: 데이터를 실시간으로 처리할 필요가 없는 경우, 배치 작업으로 묶어 처리할 수 있다. 데이터를 한꺼번에 처리하여 성능을 최적화할 수 있다.  
장점: 실시간 쿼리 부하를 줄이고, 대량 데이터를 효율적으로 처리할 수 있다.  
구현 방안:  
- 일정 시간 간격으로 배치 작업을 처리한다.  
- Spring Batch를 사용하여 대용량 데이터를 처리한다.

9. 스케일 아웃, 스케일 업
설명: 클라우드 데이터베이스 서비스를 사용하는 경우, 서버 리소스 증설 및 오토스케일링 옵션을 활용해 병목 현상을 해소할 수 있다.


## 실험

## 결론